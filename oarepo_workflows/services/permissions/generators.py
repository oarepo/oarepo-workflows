#
# Copyright (C) 2024 CESNET z.s.p.o.
#
# oarepo-workflows is free software; you can redistribute it and/or
# modify it under the terms of the MIT License; see LICENSE file for more
# details.
#
"""Permission generators usable in workflow configurations."""

from __future__ import annotations

import operator
from functools import reduce
from typing import TYPE_CHECKING, Any, override

from invenio_search.engine import dsl
from oarepo_runtime.services.generators import (
    AggregateGenerator,
    ConditionalGenerator,
    Generator,
)

from oarepo_workflows.errors import InvalidWorkflowError, MissingWorkflowError
from oarepo_workflows.proxies import current_oarepo_workflows

if TYPE_CHECKING:
    from collections.abc import Sequence

    from flask_principal import Need
    from invenio_records_permissions import RecordPermissionPolicy
    from invenio_records_permissions.generators import Generator as InvenioGenerator
    from invenio_records_resources.records import Record


class FromRecordWorkflow(Generator):
    """Permission delegating check to workflow.

    The implementation of the permission gets the workflow id from the passed context
    (record or data) and then looks up the workflow definition in the configuration.

    The workflow definition must contain a permissions policy that is then used to
    determine the permissions for the action.
    """

    _action: str

    def __init__(self, action: str) -> None:
        """Initialize the permission."""
        # might not be needed in subclasses
        super().__init__()
        self._action = action

    # noinspection PyMethodMayBeStatic
    def _get_workflow_id(self, record: Record | None = None, **context: Any) -> str:
        """Get the workflow id from the context.

        If the record is passed, the workflow is determined from the record.
        If the record is not passed, the workflow is determined from the input data.

        If the workflow is not found, an error is raised.

        :param record: Record to get the workflow from.
        :param context: Context to get the workflow from.
        :return: Workflow id.
        :raises MissingWorkflowError: If the workflow is not found in the data.
        """
        if record:
            workflow_code = current_oarepo_workflows.get_workflow(record).code
        else:
            data = context.get("data", {})
            workflow_code = data.get("parent", {}).get("workflow", {})
            if not workflow_code:
                raise MissingWorkflowError("Workflow not defined in input.", record=data)
        return workflow_code

    def _get_permissions_from_workflow(
        self,
        action_name: str,
        record: Record | None = None,
        **context: Any,
    ) -> RecordPermissionPolicy:
        """Get the permissions policy from the workflow.

        At first the workflow id is determined from the context.
        Then the permissions policy is determined from the workflow configuration,
        is instantiated with the action name and the context and the permissions
        for the action are returned.
        """
        workflow_id = self._get_workflow_id(record, **context)
        if workflow_id not in current_oarepo_workflows.workflow_by_code:
            raise InvalidWorkflowError(
                f"Workflow {workflow_id} does not exist in the configuration.",
                record=record or context.get("data", {}),
            )
        policy = current_oarepo_workflows.workflow_by_code[workflow_id].permissions
        return policy(action_name, record=record, **context)

    @override
    def needs(self, record: Record | None = None, **context: Any) -> Sequence[Need]:
        """Return needs that are generated by the workflow permission."""
        return self._get_permissions_from_workflow(self._action, record, **context).needs  # type: ignore[no-any-return]

    @override
    def excludes(self, **context: Any) -> Sequence[Need]:
        """Return excludes that are generated by the workflow permission."""
        return self._get_permissions_from_workflow(self._action, **context).excludes  # type: ignore[no-any-return]

    @override
    def query_filter(self, record: Record | None = None, **context: Any) -> dsl.query.Query:
        """Return query filters that are generated by the workflow permission.

        Note: this implementation in fact will be called from WorkflowRecordPermissionPolicy.query_filters
        for each registered workflow type. The query_filters are then combined into a single query.
        """
        # query filters do not use reduce on the list
        queries = self._get_permissions_from_workflow(self._action, record, **context).query_filters
        return reduce(operator.or_, queries) if queries else dsl.Q("match_none")


class WorkflowPermission(FromRecordWorkflow):
    """Deprecated alias for FromRecordWorkflow."""

    def __init__(self, action: str) -> None:
        """Initialize the generator."""
        import warnings

        warnings.warn(
            "WorkflowPermission is deprecated. Use FromRecordWorkflow instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        super().__init__(action)


class IfInState(ConditionalGenerator):
    """Generator that checks if the record is in a specific state.

    If it is in the state, the then_ generators are used, otherwise the else_ generators are used.

    Example:
        .. code-block:: python

            can_edit = [
                IfInState("draft", [RecordOwners()])
            ]

    """

    def __init__(
        self,
        state: str | list[str] | tuple[str, ...],
        then_: Sequence[InvenioGenerator],
        else_: Sequence[InvenioGenerator] | None = None,
    ) -> None:
        """Initialize the generator."""
        if isinstance(state, str):
            state = [state]
        if not isinstance(state, list | tuple):
            raise TypeError(f"State must be a string, list or tuple. Got {type(state)}.")
        self.state = state
        super().__init__(then_, else_ or [])

    @override
    def _condition(self, record: Record, **context: Any) -> bool:  # type: ignore[reportIncompatibleMethodOverride]
        """Check if the record is in the state."""
        try:
            return record.state in self.state  # type: ignore[reportAttributeAccessIssue]
        except AttributeError:
            return False

    @override
    def _query_instate(self, **context: Any) -> dsl.query.Query:
        return dsl.Q("terms", state=self.state)

    def __repr__(self) -> str:
        """Return representation of the generator."""
        return f"IfInState({self.state}, then={self.then_!r}, else={self.else_!r})"

    def __str__(self) -> str:
        """Return string representation of the generator."""
        return repr(self)


class SameAs(AggregateGenerator):
    """Generator that delegates the permissions to another action.

    Example:
        .. code-block:: python
            class Perms:
                can_create_files = [
                    SameAs("edit_files")
                ]
                can_edit_files = [RecordOwners()]

    would mean that the permissions for creating files are the same as for editing files.
    This works even if you inherit from the class and override the can_edit_files.

    """

    def __init__(self, permission_name: str) -> None:
        """Initialize the generator.

        :param permission_name: Name of the permission to delegate to. In most cases,
        it will look like "can_<action>". A property with this name must exist on the policy
        and its value must be a list of generators.
        """
        self.delegated_permission_name = permission_name

    @override
    def _generators(self, policy: RecordPermissionPolicy, **context: Any) -> Sequence[Generator]:  # type: ignore[override]
        """Get the generators from the policy."""
        return getattr(policy, self.delegated_permission_name)  # type: ignore[no-any-return]

    @override
    def needs(self, policy: RecordPermissionPolicy | None = None, **context: Any) -> Sequence[Need]:  # type: ignore[reportIncompatibleMethodOverride]
        """Get the needs from the policy."""
        if policy is None:
            raise ValueError(
                f"SameAs: Policy must be passed to the generator. Got the following context: {context.keys()}"
            )
        # the type: ignore should not be necessary here
        return super().needs(**context | {"policy": policy})  # type: ignore[no-any-return]

    @override
    def excludes(self, policy: RecordPermissionPolicy | None = None, **context: Any) -> Sequence[Need]:  # type: ignore[reportIncompatibleMethodOverride]
        """Get the excludes from the policy."""
        if policy is None:
            raise ValueError(
                f"SameAs: Policy must be passed to the generator. Got the following context: {context.keys()}"
            )
        return super().excludes(**context | {"policy": policy})  # type: ignore[no-any-return]

    @override
    def query_filter(self, policy: RecordPermissionPolicy | None = None, **context: Any) -> dsl.query.Query:  # type: ignore[reportIncompatibleMethodOverride]
        """Get the query_filter from the policy."""
        if policy is None:
            raise ValueError(
                f"SameAs: Policy must be passed to the generator. Got the following context: {context.keys()}"
            )
        return super().query_filter(**context | {"policy": policy})

    def __repr__(self) -> str:
        """Return representation of the generator."""
        return f"SameAs({self.delegated_permission_name})"

    def __str__(self) -> str:
        """Return String representation of the generator."""
        return repr(self)
